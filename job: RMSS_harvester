Step 1: Start Harvester

Step 2: Harvest RMSS Data

[Net.ServicePointManager]::SecurityProtocol = "tls12";

$Server = "eagnmnwbp1664"; #SQL Server Instance.
$Src_Database = "rdv_dw"; #Database
$PayData_con = New-Object Data.SqlClient.SqlConnection; 
$PayData_con.ConnectionString = "Data Source=$Server;" +  
                        "Integrated Security=True;" + 
                        "Initial Catalog=$Src_Database";
                        
$PayData_Sql = "declare 
@MaxFYWk int,
@PayYear char(4),
@PayNbr varchar(2),
@PayYrNbr varchar(6),
@URIBase varchar(255),
@RecordsPerPage varchar(255),
@DataPathFile varchar(255),
@BackupPath varchar(255);

select @MaxFYWk = max(re_ppfy*100 + re_ppwk) 
from rdv_dw.dbo.rural_extract_out with (nolock);

select 
    @URIBase = web_service_base_url,
    @RecordsPerPage = cast(records_per_page as varchar(255)),
    @DataPathFile = data_file_path + data_file_name,
    @BackupPath = backup_path 
from rdv_dw.dbo.rural_extract_web_service_meta with (nolock);

select
    @PayYrNbr = cast(pay_year as char(4)) + right('0' + cast(pay_period as varchar(2)), 2),
    @PayYear = cast(pay_year as char(4)),
    @PayNbr = right('0'+cast(pay_period  as varchar(2)), 2)
from pcdv_dw.dbo.Master_Calendar_daily
where pay_year * 100 + pay_period > @MaxFYWk 
order by variance_full_week desc;

select 
    @PayYrNbr PayYrNbr,
    @URIBase + @PayNbr + '&payPeriodYear=' + @PayYear + '&size=' + @RecordsPerPage URI,
    @DataPathFile data_file,
    @BackupPath backup_path;";
                        
                        
$PayData_con.Open();
$PayData_cmd = New-Object Data.SqlClient.SqlCommand $PayData_Sql, $PayData_con;
$PayData_rd = $PayData_cmd.ExecuteReader();
$PayYrWk = [string]"";
$URI = [string]"";
$OutputPathFile = [string]"";
$BackupPath = [string]"";

While ($PayData_rd.Read()) {
    $PayYrWk = $PayData_rd.GetValue(0);
    $URI = $PayData_rd.GetValue(1);
    $OutputPathFile = $PayData_rd.GetValue(2);
    $BackupPath = $PayData_rd.GetValue(3);
}

$PayData_rd.Close();
$PayData_cmd.Dispose();
$PayData_con.Close();

#convert the string variable for insertion into the data set
$PayYrNum = [int]$PayYrWk.Substring(0,4);
$PayWkNum = [int]$PayYrWk.Substring(4);
$PayYrWkNum = $PayYrNum * 100 + $PayWkNum;

$FileStamp = "_" + [System.DateTime]::Now.ToString("yyyyMMdd_HHmmss");

if (Test-Path $OutputPathFile) {
  $file   = [io.path]::GetFileNameWithoutExtension($OutputPathFile);
  $ext    = [io.path]::GetExtension($OutputPathFile);
  $Target = $BackupPath + $file + $FileStamp + $ext;
  Move-Item $OutputPathFile $Target;
}

Invoke-WebRequest -Method GET -Uri $URI -UseBasicParsing |
 ConvertFrom-Json |
 Select-Object -ExpandProperty  data |
 #Select-Object -Property finance,routeNumber,bankTime,finDataCtrlNo,routeType,routeEval,routeLength,stops,vehicleType,rotatingRelief,lockPouchRate,lockPouchStops,detour,detourMiles,seasonal,inSeason,seasonalMiles,seasonalRegularBoxes,seasonalCentralizedBoxes,optionElection,regularBoxes,centralizedBoxes,volumeOnly,ema,dismounts,dismountFeet,collectionCompartments,parcelLockers,ppYear,ppNumber,lroute,routeMilesRounded,standardHours,standardMinutes,routeStatus,auxPayType,effectiveYearPeriod,processedYearPeriod,recordId,seasonalYearPeriod,ppYearPpNumber | 
 #Select-Object -Property finance,routeNumber,effectiveYearPeriod,routeType,optionElection,routeEval,routeMilesRounded,stops,regularBoxes,centralizedBoxes,volumeOnly,lroute,vehicleType,ema,lockPouchRate,routeLength,standardHours,standardMinutes,bankTime,lockPouchStops,dismounts,dismountFeet,detour,detourMiles,seasonal,seasonalYearPeriod,inSeason,seasonalMiles,seasonalRegularBoxes,seasonalCentralizedBoxes,collectionCompartments,parcelLockers,@{Name='ppYearPpNumber';Expression={$PayYrWkNum}} | 
 Select-Object -Property finance,routeNumber,effectiveYearPeriod,routeType,optionElection,routeEval,routeMilesRounded,stops,regularBoxes,centralizedBoxes,volumeOnly,lroute,vehicleType,ema,lockPouchRate,routeLength,standardHours,standardMinutes,bankTime,lockPouchStops,dismounts,dismountFeet,detour,detourMiles,seasonal,seasonalYearPeriod,inSeason,seasonalMiles,seasonalRegularBoxes,seasonalCentralizedBoxes,collectionCompartments,parcelLockers,ppYearPpNumber | 
 ConvertTo-CSV -NoTypeInformation |
 Select -Skip 1 |
 % {$_.Replace('"','')} |
Set-Content $OutputPathFile;










Step 3: Procedure: 

exec dbo.pr_generate_rural_extract


USE [RDV_DW]
GO
/****** Object:  StoredProcedure [dbo].[pr_generate_rural_extract]    Script Date: 1/7/2026 3:32:16 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Authors:			CBA/JWILD
-- Create date: 20190606
-- Description:	Converts regular csv file to signed overpunch file necessary for rural refresh
--							Source data to be migrated from Eagan to St Louis (RMSS) in Winter 2020
--							RMSS does not have the data in signed overpunch format, necessitating this loader
--							Creating a signed overpunch file means we could leave the regular process untouched, thus lower risk this way
-- =============================================
ALTER PROCEDURE [dbo].[pr_generate_rural_extract]
AS
BEGIN

BEGIN TRY

--ingest raw data
truncate table dbo.import_rural_webservice_extract;

declare 
@SQL_Command varchar(4000),
@FileName varchar(100) = '';

select @FileName = data_file_path + data_file_name
from rdv_dw.dbo.rural_extract_web_service_meta with (nolock);

SET @SQL_Command = 'BULK INSERT rdv_dw.dbo.vw_import_rural_webservice_extract from ''' + 
						    @FileName + '''' + ' WITH (FIRSTROW=1, FIELDTERMINATOR= '','', ROWTERMINATOR=''\n'')';

EXEC (@SQL_Command);

--cursor based solution using format table
declare @serverColName varchar(50)
	,@length int
	,@padding varchar(50)
	,@overpunch bit
	,@side char(1)
	,@trueFalse bit
	,@decMultiplier varchar(3)
	,@webName varchar(50)
	,@SQLCmd varchar(4000)
    ,@ErrorMessage nvarchar(2048);

declare overpunchCursor cursor for
select server_column_name
			, host_file_data_length
			, coalesce(column_padding_ascii_code,48) --some not padded because we expect full length data, but can't pass Null to dynamic SQL so use coalesce here and pad them as L
			, column_is_overpunch
			, coalesce(column_padding_side,'L') --some not padded because we expect full length data, but can't pass Null to dynamic SQL so use coalesce here and pad them as L
			, true_false_indicator --where the raw data will spell out True or False, we need to convert to single Y or N
			, cast(decimal_multiplier as varchar(3)) --convert it here to make it easier in dynamic sql below
			, webservice_column_name --in conjunction with column_is_overpunch determines fields we won't get data for but need to be overpunched 0
from dbo.rural_extract_format_meta
order by host_file_field_order;

open overpunchCursor;


declare @wasPrinted INT = 0;


fetch next from overpunchCursor into @serverColName, @length, @padding, @overpunch, @side, @trueFalse, @decMultiplier, @webName;

while @@fetch_status = 0
begin


begin try

set @SQLCmd = N'';

--True/False logic is specific to each column
if @trueFalse = 1 and @serverColName = 're_high_den_rte_code'
		set @SQLCmd = 
		N'update t1
		set ' + @serverColName + '= case when ' + @serverColName + ' = ''True'' then ''L'' else '' '' end
		from dbo.import_rural_webservice_extract t1;';

if @trueFalse = 1 and @serverColName = 're_sea_rte'
		set @SQLCmd = 
		N'update t1
		set ' + @serverColName + '= case when ' + @serverColName + ' = ''True'' then ''S'' else '' '' end
		from dbo.import_rural_webservice_extract t1;';

if @trueFalse = 1 and @serverColName = 're_in_sea_ind' 
		set @SQLCmd =
		N'update t1
		set ' + @serverColName + '= case when ' + @serverColName + ' = ''True'' then ''Y'' when ' + @serverColName + ' = ''False'' and re_sea_rte = ''S'' then ''N'' else '' '' end
		from dbo.import_rural_webservice_extract t1;';        

if @trueFalse = 1 and @serverColName = 're_detour_route' --source data only contains True/False.
        set @SQLCmd = 
        N'update t1
        set ' + @serverColName + '= case when ' + @serverColName + ' = ''True'' then ''Y'' else ''N'' end
        from dbo.import_rural_webservice_extract t1;';

--Remaining columns i.e. non-True/False
if @overpunch = 1 and @trueFalse = 0 and @webName <> '' --overpunch always left padded (concat padding with field and take rightmost char)		       
        set @SQLCmd = 
		N'update t1
		set ' +@serverColName+ ' = STUFF(right(concat(replicate(char(' +@padding+ '), ' +cast(@length as varchar(3))+ '), abs(cast(cast(' +@serverColName+ ' as numeric(10,2)) * ' + @decMultiplier + ' as int))),' +cast(@length as varchar(3))+ '), ' +cast(@length as varchar(3))+ ', 1, code)
		from dbo.import_rural_webservice_extract t1, dbo.overpunch t2
		where (case when CAST(' +@serverColName+ ' as numeric(10,2)) * ' + @decMultiplier + ' = 0 then 1 else cast(cast(' +@serverColName+ ' as numeric(10,2)) * ' + @decMultiplier + ' as int)/abs(cast(cast(' +@serverColName+ ' as numeric(10,2)) * ' + @decMultiplier + ' as int)) end) = multiplier
		and right(cast(cast(' +@serverColName+ ' as numeric(10,2)) * ' + @decMultiplier + ' as int) ,1) = digit;';

if @overpunch = 1 and @webName = '' and @trueFalse = 0 --fields we won't get data for but need to be overpunched 0
		set @SQLCmd = 
		N'update t1
		set ' +@serverColName+ ' = STUFF(right(concat(replicate(char(' +@padding+ '), ' +cast(@length as varchar(3))+ '), abs(cast(cast(' +@serverColName+ ' as numeric(10,2)) * ' + @decMultiplier + ' as int))),' +cast(@length as varchar(3))+ '), ' +cast(@length as varchar(3))+ ', 1, code)
		from dbo.import_rural_webservice_extract t1, dbo.overpunch t2
		where multiplier = 1;'; --force it to use positive 0 code

if @overpunch = 0 and @side = 'L' and @trueFalse = 0 --left padded (concat padding with field and take rightmost char)
		set @SQLCmd = 
		N'update t1
		set ' +@serverColName+ ' = right(concat(replicate(char(' +@padding+ '), ' +cast(@length as varchar(3))+ '), ' +@serverColName+ '),' +cast(@length as varchar(3))+ ')
		from dbo.import_rural_webservice_extract t1;';
		
if @overpunch = 0 and @side = 'R' and @trueFalse = 0 --right padded (concat field with padding and take leftmost char)
		set @SQLCmd = 
		N'update t1
		set ' +@serverColName+ ' = left(concat(' +@serverColName+ ', replicate(char(' +@padding+ '), ' +cast(@length as varchar(3))+ ')),' +cast(@length as varchar(3))+ ')
		from dbo.import_rural_webservice_extract t1;';

exec (@SQLCmd);

end try
begin catch

PRINT @SQLCmd;

set @ErrorMessage = CONCAT('ERROR on column ', @serverColName, ' on line ', ERROR_LINE(), '; Message: ', ERROR_MESSAGE());

throw 51000, @ErrorMessage, 1;

end catch


fetch next from overpunchCursor into @serverColName, @length, @padding, @overpunch, @side, @trueFalse, @decMultiplier, @webName;

end -- end cursor

close overpunchCursor;
deallocate overpunchCursor;

--use a view that concats all fields in proper order and bcp out to rural_extract.DAT
declare 
    @export_to_rural_extract_dat varchar(4000)
	,@filestamp char(16);

exec var_servers.dbo.pr_get_filestamp @filestamp = @filestamp output;

set @export_to_rural_extract_dat = 'bcp "SELECT * FROM rdv_dw.dbo.vw_import_rural_webservice_extract_output" queryout e:\data\Rural\RURAL_EXTRACT' + @filestamp + '.DAT -c -T -t,';

exec master..xp_cmdshell @export_to_rural_extract_dat;

end try
begin catch

set @ErrorMessage = CONCAT('ERROR on line ', ERROR_LINE(), '; Message: ', ERROR_MESSAGE());

throw 51000, @ErrorMessage, 1;

end catch


END





Step 4: 

#[Net.ServicePointManager]::SecurityProtocol = "tls12";

$Server = "eagnmnwbp1664"; #SQL Server Instance.
$Src_Database = "rdv_dw"; #Database
$PayData_con = New-Object Data.SqlClient.SqlConnection; 
$PayData_con.ConnectionString = "Data Source=$Server;" +  
                        "Integrated Security=True;" + 
                        "Initial Catalog=$Src_Database";
                        
$PayData_Sql = "select 
    data_file_path + data_file_name data_file,
    backup_path 
from rdv_dw.dbo.rural_extract_web_service_meta with (nolock);";
                        
$PayData_con.Open();
$PayData_cmd = New-Object Data.SqlClient.SqlCommand $PayData_Sql, $PayData_con;
$PayData_rd = $PayData_cmd.ExecuteReader();
$PayYrWk = [string]"";
$URI = [string]"";
$OutputPathFile = [string]"";
$BackupPath = [string]"";

While ($PayData_rd.Read()) {
    $OutputPathFile = $PayData_rd.GetValue(0);
    $BackupPath = $PayData_rd.GetValue(1);
}

$PayData_rd.Close();
$PayData_cmd.Dispose();
$PayData_con.Close();

$FileStamp = "_" + [System.DateTime]::Now.ToString("yyyyMMdd_HHmmss");

if (Test-Path $OutputPathFile) {
  $file   = [io.path]::GetFileNameWithoutExtension($OutputPathFile);
  $ext    = [io.path]::GetExtension($OutputPathFile);
  $Target = $BackupPath + $file + $FileStamp + $ext;
  Move-Item $OutputPathFile $Target;
}


